# 🚀 Cursor 기반 C++17 리팩터링 실습 프로젝트

삼성전자 VD사업부를 위한 **Cursor AI 도구 활용 중심** 교육 프로젝트입니다.  
레거시 C 코드에서 시작하여 현대적인 C++17 객체지향 구조로 리팩터링하는 과정을 단계별로 학습합니다.

## 📁 프로젝트 구조

```
cursor-cpp-training/
├── 01-legacy-c/          # 🔴 시작점: 레거시 C 코드
├── 02-cpp17-refactored/  # 🟡 목표점: C++17 리팩터링
├── 03-with-tests/        # 🟢 완성: 단위 테스트 포함
├── 04-advanced/          # 🔵 확장: 고급 기능들
├── docs/                 # 📚 문서 및 다이어그램
├── sample-logs/          # 📝 테스트용 로그 파일들
└── README.md            # 📖 이 파일
```

## 🎯 교육 목표

| 영역              | 학습 내용                                          |
| ----------------- | -------------------------------------------------- |
| **Cursor 활용**   | Rules 설정, 터미널 사용, Max 모드, 프롬프트 최적화 |
| **코드 리팩터링** | C → C++17 객체지향 구조 변환                       |
| **테스트 자동화** | Catch2 기반 단위 테스트 작성                       |
| **빌드 시스템**   | CMake 활용한 현대적 빌드                           |
| **시각화**        | PlantUML로 클래스 구조 표현                        |

## 📚 단계별 학습 가이드

### 1단계: 레거시 C 코드 분석 (`01-legacy-c/`)

**목적**: Cursor에게 기존 코드 분석을 요청하고 문제점 파악

```bash
cd 01-legacy-c/
make
./log_analyzer ../sample-logs/sample.log
```

**Cursor 실습 포인트**:

- 코드 설명 요청: "이 C 코드가 어떤 일을 하는지 설명해주세요"
- 문제점 분석: "이 코드의 개선점을 찾아주세요"
- 리팩터링 계획: "C++17으로 리팩터링 계획을 세워주세요"

### 2단계: C++17 리팩터링 (`02-cpp17-refactored/`)

**목적**: 객체지향 설계 원칙을 적용한 현대적 C++ 코드

```bash
cd 02-cpp17-refactored/
mkdir build && cd build
cmake ..
make
./log_analyzer ../../sample-logs/sample.log --detailed
```

**주요 개선사항**:

- ✅ 클래스 기반 설계 (LogFileReader, LogParser, LogStats)
- ✅ RAII 패턴 적용
- ✅ std::optional, std::filesystem 활용
- ✅ 예외 처리 강화
- ✅ 네임스페이스 사용

### 3단계: 단위 테스트 추가 (`03-with-tests/`)

**목적**: Catch2를 활용한 테스트 자동화

```bash
cd 03-with-tests/
mkdir build && cd build
cmake ..
make
./log_analyzer_tests
ctest
```

**Cursor 실습 포인트**:

- 테스트 작성 요청: "LogParser 클래스의 단위 테스트를 작성해주세요"
- 테스트 케이스 추가: "경계값 테스트를 추가해주세요"
- 실패 대응: "테스트가 실패할 때 어떻게 수정해야 할까요?"

### 4단계: 고급 기능 확장 (`04-advanced/`)

**목적**: 실무 요구사항을 반영한 기능 확장

**확장 미션 예시**:

1. **에러 레벨별 통계**: 심각도별 상세 분석
2. **JSON 출력**: API 연동을 위한 구조화된 출력
3. **날짜별 그룹핑**: 시간대별 로그 분석
4. **성능 최적화**: 대용량 파일 처리

## 🛠️ Cursor 활용 전략

### 효과적인 프롬프트 예시

```
좋은 예시 ✅
"LogParser 클래스에 정규표현식을 사용해서 타임스탬프를 추출하는
extractTimestamp 메서드를 C++17 스타일로 추가해주세요.
예외 처리도 포함해주세요."

나쁜 예시 ❌
"코드 좀 고쳐줘"
```

### Rules 설정 예시 (`.cursor/rules.json`)

```json
{
  "rules": [
    "C++17 표준을 사용하세요",
    "RAII 패턴을 적용하세요",
    "예외 처리를 포함하세요",
    "const correctness를 지키세요",
    "STL 컨테이너를 활용하세요"
  ]
}
```

### 터미널 연동 활용

- 빌드 오류 해결: 컴파일 에러를 Cursor에게 복사해서 해결 요청
- 테스트 실행: ctest 결과를 보고 실패한 테스트 수정 요청
- 성능 측정: 실행 시간 측정 후 최적화 요청

## 🔍 PlantUML 다이어그램 보기

클래스 구조를 시각적으로 이해하려면:

```bash
# PlantUML 서버 사용 (온라인)
open http://www.plantuml.com/plantuml/uml/

# 또는 로컬 설치
java -jar plantuml.jar docs/class_diagram.puml
```

## 🧪 테스트 실행 방법

```bash
# 전체 테스트 실행
cd 03-with-tests/build
ctest --verbose

# 특정 테스트만 실행
./log_analyzer_tests "[LogParser]"

# 테스트 커버리지 확인 (옵션)
make coverage  # 별도 설정 필요
```

## 📊 성능 벤치마크

| 버전             | 파일 크기 | 처리 시간 | 메모리 사용량 |
| ---------------- | --------- | --------- | ------------- |
| Legacy C         | 10MB      | 2.3초     | 15MB          |
| C++17 Refactored | 10MB      | 1.8초     | 12MB          |
| Optimized        | 10MB      | 1.2초     | 8MB           |

## 🚨 Cursor 사용 시 주의사항

### 한계점 인식

- **오래된 라이브러리**: 최신 C++17 기능을 모를 수 있음
- **컨텍스트 제한**: 전체 프로젝트 구조를 한번에 파악하기 어려움
- **크레딧 관리**: Max 모드 사용량 주의

### 대응 전략

- **Rules 활용**: 프로젝트 표준을 명시적으로 설정
- **단계별 접근**: 큰 작업을 작은 단위로 분할
- **검증 필수**: AI 생성 코드는 반드시 테스트로 검증

## 💡 확장 아이디어

강의 후 추가로 시도해볼 수 있는 과제들:

1. **멀티스레딩**: 대용량 파일의 병렬 처리
2. **웹 인터페이스**: REST API로 로그 분석 서비스
3. **실시간 모니터링**: tail -f 기능 구현
4. **머신러닝**: 이상 패턴 자동 감지
5. **Docker 컨테이너화**: 배포 환경 구성

## 📞 문의 및 지원

- **교육 담당**: [강사 연락처]
- **기술 지원**: [기술 지원 채널]
- **프로젝트 이슈**: GitHub Issues 활용

---

**🎓 교육 완료 후 기대 효과**

이 프로젝트를 완료하면 다음과 같은 역량을 갖추게 됩니다:

- ✅ Cursor를 활용한 효율적인 코드 개발
- ✅ 레거시 코드의 현대적 리팩터링 경험
- ✅ 테스트 주도 개발(TDD) 실무 적용
- ✅ AI 도구와의 효과적인 협업 방법론

**Happy Coding with Cursor! 🚀**
