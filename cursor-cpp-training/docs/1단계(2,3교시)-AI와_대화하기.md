# 🎯 1단계 (2~3교시): C 코드 분석 및 C++17로의 전환

> **학습 목표**: **하나의 폴더 안에서** 레거시 C 프로젝트를 분석하고, AI와 함께 기존 파일을 삭제하며 C++17 기반의 객체지향 프로젝트로 완전히 **전환(Transform)**하는 과정을 경험합니다.

---

## ⏰ 2교시 (10:00~10:50): 레거시 C 코드 분석 및 리팩터링 방향 수립

**목표: `01-legacy-c` 폴더의 C 코드를 AI와 함께 분석하고, 직접 빌드/실행하며 리팩터링의 필요성을 이해합니다.**

### 실습 1: 레거시 코드 분석 및 실행

#### 1. 목표 확인 및 AI에게 요청

`01-legacy-c` 폴더의 코드와 빌드 스크립트가 무슨 일을 하는지 AI에게 물어봅니다.

```
📝 프롬프트 예시:
@cursor-cpp-training/01-legacy-c/log_analyzer.c
@cursor-cpp-training/01-legacy-c/Makefile

"이 C 코드와 Makefile은 어떤 역할을 하나요?
이 프로젝트를 컴파일하고 실행하는 전체 과정을 설명해주세요."
```

#### 2. 코드 컴파일 및 실행

AI가 알려준 대로 터미널에서 코드를 빌드하고 실행하여 현재 상태를 확인합니다.

```bash
# 01-legacy-c 디렉토리에서 실행
cd cursor-cpp-training/01-legacy-c/
make clean && make
./log_analyzer ../sample-logs/sample.log
```

#### 3. 코드 문제점 진단

이제 이 코드의 문제점을 찾아달라고 요청하여 C++로 전환해야 하는 이유를 명확히 합니다.

```
📝 프롬프트 예시:
@cursor-cpp-training/01-legacy-c/log_analyzer.c
"이 C 코드의 문제점을 C++17 관점에서 분석해주세요.
특히 메모리 관리, 에러 처리, 코드 구조 측면에서 개선할 점을 알려주세요."
```

#### 4. 추가 탐구

AI가 지적한 문제점 중 'RAII'의 개념에 대해 더 깊이 질문해봅니다.

```
📝 프롬프트 예시:
"RAII 패턴이 무엇인지 C 코드의 fopen/fclose와 비교해서 설명해줘. 왜 RAII가 더 안전한 거야?"
```

---

## ⏰ 3교시 (11:00~11:50): C++ 프로젝트로 전환 및 첫 빌드

**목표: 기존 C 파일을 삭제하고, 그 자리에 C++ 클래스 파일과 CMake 빌드 시스템을 도입하여 C++ 프로젝트로의 완전한 전환을 수행하고, 첫 컴파일 오류를 해결합니다.**

### 실습 2: C++ 프로젝트로 전환하기

#### 1. C 프로젝트 파일 삭제 및 C++ 클래스 생성

과감하게 기존 C 파일들을 지우고, 첫 C++ 클래스 파일을 생성해달라고 AI에게 요청합니다.

```
📝 프롬프트 예시:
"이제 이 프로젝트를 C++17로 전환하려고 해.
먼저 `cursor-cpp-training/01-legacy-c/` 폴더에서 `log_analyzer.c`와 `Makefile`을 삭제해줘.

그리고 그 폴더 안에, `LogFileReader` 클래스를 C++17 스타일로 새로 만들어줘.
- 헤더(.hpp)와 구현(.cpp) 파일을 분리해줘."
```

#### 2. CMake 빌드 시스템 도입

이제 새로운 C++ 파일을 빌드하기 위한 `CMakeLists.txt`와 임시 `main.cpp` 생성을 요청합니다.

```
📝 프롬프트 예시:
"`cursor-cpp-training/01-legacy-c/` 폴더에 `LogFileReader`를 빌드하고 실행할 수 있도록,
최소한의 내용을 담은 `main.cpp`와 `CMakeLists.txt`를 만들어줘."
```

이제 터미널에서 C++ 프로젝트로의 첫 빌드를 시도합니다.

```bash
# 01-legacy-c 폴더에서 실행
cd cursor-cpp-training/01-legacy-c/
rm -rf build
mkdir build && cd build
cmake ..
make
```

#### 3. 컴파일 오류 디버깅

높은 확률로 발생하는 컴파일 오류를 해결하는 과정은 매우 중요합니다. 오류 메시지를 AI에게 보여주고 해결책을 받으세요.

```
📝 프롬프트 예시:
"C++로 전환 후 첫 빌드를 했는데, make 실행 중 컴파일 오류가 발생했어. 해결해줘.

[터미널의 오류 메시지를 그대로 붙여넣기]

어떤 부분이 문제였고 어떻게 수정했는지 설명해줘."
```

#### 4. 추가 탐구

성공적으로 빌드가 완료되면, 빌드 시스템의 변화에 대해 질문해보세요.

```
📝 프롬프트 예시:
"기존의 Makefile과 지금 만든 CMake의 차이점은 뭐야? 왜 최신 C++ 프로젝트에서는 CMake를 더 선호해?"
```

## 📊 1단계 완료 체크리스트

- [ ] C 레거시 코드를 직접 빌드하고 실행해보기
- [ ] 기존 C 파일을 **삭제**하고 C++ 클래스 파일을 그 자리에 생성하기
- [ ] Makefile을 **삭제**하고 CMake 빌드 시스템 도입하기
- [ ] C++ 프로젝트의 첫 **컴파일 오류를 AI와 함께 해결하기**
