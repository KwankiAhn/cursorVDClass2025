# 프롬프트

## 실습 1: 커서로 기능 개발 (PoC) - 간단한 Android 앱 생성 - 프롬프트 기반 수정 실습

```markdown
⸻

✅ 1. Project Overview (프로젝트 개요)

앱 이름: My Device Info (또는 DeviceStatusViewer)
목적: 사용자의 디바이스 상태(배터리, 네트워크, OS 등)를 한눈에 보여주는 Android 앱
타깃 사용자: 일반 사용자, 개발자, 테스트 목적의 QA
사용 기술: Kotlin  기반 / MVVM 아키텍처

⸻

✅ 2. Core Functionality (핵심 기능)

기능 설명
🔋 배터리 정보 확인 배터리 잔량, 충전 상태 조회 (BatteryManager)
📶 네트워크 상태 확인 Wi-Fi 연결 여부, 네트워크 타입 (ConnectivityManager)
📱 디바이스 정보 모델명, 제조사, OS 버전, API 레벨 (Build.VERSION, Build.MODEL)
💾 저장 공간 조회 내부 저장소 총 용량 / 사용 가능 용량 (StatFs)
🌐 위치 권한 여부 위치 권한 허용 여부 확인 (권한 요청 UI 포함)

⚠️ 모든 기능은 시뮬레이터에서 동작 가능한 항목으로 구성

⸻

✅ 3. Docs

⸻

✅ 4. File Structure (폴더 구조)
```


@prd.md 해당 파일을 기준으로 작업을 진행합니다. 

1. docs 부분과 폴더구조 부분을 설계 해주세요
2. 해당 프로젝트를 구현하기 위한 체크 리스트를 만들어주세요
3. 1번과 2번이 완료 된 후 체크 리스트에 작성된 작업에 따라서 작업을 시작하고, 작업이 완료되면 업데이트하면서 진행하세요.

## 디자인 개선

```markdown
안드로이드 앱의 UI를 어두운 테마로 바꾸고, 카드에 3D 느낌을 주며 정렬 버튼도 추가하고 싶어요.  
아래 조건에 맞게 단계별로 코드와 설명을 정리해해주세요

1. 전체 앱에 다크 테마 적용 (Material3 기준)
2. CardView에 그림자/입체감 있는 스타일 적용
3. 카드 위에 정렬 버튼 3개 (기본/이름순/타입순) 추가
4. 버튼 클릭 시 카드 정렬되도록 MainActivity에 로직 구현
5. 정렬 시 애니메이션이 자연스럽게 적용되면 좋겠음
6. 카드들이 공중에 있어 진짜 3D 오브젝트로 느껴지게
```

## 실습 2: 코드 리팩토링 + 문서화 자동화 - README, 함수 주석 자동 생성

1. **Cursor를 활용해 해당 파일의 문제점 분석**

```markdown
다음 파일에 현재 프로젝트에 대한 리팩토링 계획 문서를 작성해주세요.

1. 먼저 코드에서 어떤 문제가 있는지 **실무자 관점에서 설명**해주세요.
    - 예: 코드 중복, null 처리 누락, 책임 분리 부족 등
    - 단순한 현상 나열이 아니라 **왜 문제가 되는지**, 
    어떤 상황에서 문제가 될 수 있는지를 설명해주세요.
    
2. 그런 다음, 문제 해결을 위한 **리팩토링 계획을 작성**해주세요.
    - 어떤 방식으로 개선할 수 있을지
    - 구체적인 **작업 순서를 체크리스트 형식**으로 정리해주세요.
    - 가능한 경우 함수 단위 또는 책임 단위로 나눠서 설명해주세요.
```

## 실습 4 Gemini API 실전 활용

```markdown
현재 프로젝트는 Google에서 제공하는 Gemini API 테스트 템플릿을 기반으로 하고 있으며,
API 키는 @local.properties 파일에 저장되어 있습니다.

기본적인 프로젝트 구조는 이미 갖춰져 있고,
이제 여기에 기능을 확장하여 사용자가 음식 사진을 업로드하면 
Gemini API가 해당 이미지를 분석하여 음식 이름과 영양 정보를 반환하는 앱으로 발전시키고자 합니다.
Gemini 모델은 Gemini-2.0-flash 를 사용합니다.
```

온보딩 로직 변경

```markdown
✅ 앱 실행 초기 로직 (온보딩 + 영양소 계산 흐름)

1.	온보딩 시작
•	사용자에게 신체 정보(예: 키, 체중, 나이, 성별) 및
건강 관리 목표(예: 체중 감량, 근육 증가, 유지 등)를 입력받는다.

2.	입력 정보 로컬 저장
•	수집한 정보를 **로컬 기기 (예: SharedPreferences 또는 Room DB)**에 저장하여,
앱 재실행 시에도 유지되도록 한다.

3.	온보딩 종료 후 Gemini API 호출
•	저장된 사용자 정보를 기반으로,
Gemini API에 사용자 상태 및 목표를 전달하여
개인 맞춤형 1일 권장 영양소 섭취량 및 식사 계획을 요청한다.

4.	응답 데이터 로컬 저장
	•	Gemini로부터 받은 추천 영양 정보(예: 칼로리, 단백질, 탄수화물, 지방 등)를
로컬에 저장하여 앱 내에서 식단 기록이나 추천 기능에 활용할 수 있도록 한다.

5. Gemini가 계산한 데이터를 차트 형식으로 보여주세요
```

영양소 정보 받아오기 업그레이드

```markdown
사용자가 음식 사진을 업로드하면, Gemini API에 해당 이미지를 전달하여 음식 이름,
 예상 칼로리, 탄수화물, 단백질, 지방 함량, 주요 재료 등을 포함한 분석 결과를 JSON 형식으로 받아옵니다.
  Gemini는 이와 함께 음식에 대한 간단한 건강 평가, 사용자의 목표에 대한 적합도, 
  그리고 다음 식사에 대한 추천도 함께 생성합니다.

받아온 JSON 데이터는 앱 내에서 텍스트 형태로 시각화하여 사용자에게 표시하고,
 동시에 로컬 저장소(Room 또는 SharedPreferences 등)에 저장하여 
 추후 영양 기록 및 리포트에 활용할 수 있도록 합니다.

이 과정을 통해 사용자는 음식 사진만 업로드해도 자동으로 영양 정보와 건강 조언을 받을 수 있으며,
 이를 기반으로 자신의 식습관을 점검하거나 개선하는 데 도움을 받을 수 있습니다
```
